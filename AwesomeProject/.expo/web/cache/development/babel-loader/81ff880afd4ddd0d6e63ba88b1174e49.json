{"ast":null,"code":"import _defineProperty from \"@babel/runtime/helpers/defineProperty\";\nimport _classCallCheck from \"@babel/runtime/helpers/classCallCheck\";\nimport _createClass from \"@babel/runtime/helpers/createClass\";\n\nfunction ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }\n\nfunction _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? ownKeys(Object(source), !0).forEach(function (key) { _defineProperty(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }\n\nvar TextExtraction = function () {\n  function TextExtraction(text, patterns) {\n    _classCallCheck(this, TextExtraction);\n\n    this.text = text;\n    this.patterns = patterns || [];\n  }\n\n  _createClass(TextExtraction, [{\n    key: \"parse\",\n    value: function parse() {\n      var _this = this;\n\n      var parsedTexts = [{\n        children: this.text\n      }];\n      this.patterns.forEach(function (pattern) {\n        var newParts = [];\n        var tmp = pattern.nonExhaustiveModeMaxMatchCount || 0;\n        var numberOfMatchesPermitted = Math.min(Math.max(Number.isInteger(tmp) ? tmp : 0, 0) || Number.POSITIVE_INFINITY, Number.POSITIVE_INFINITY);\n        var currentMatches = 0;\n        parsedTexts.forEach(function (parsedText) {\n          if (parsedText._matched) {\n            newParts.push(parsedText);\n            return;\n          }\n\n          var parts = [];\n          var textLeft = parsedText.children;\n          var indexOfMatchedString = 0;\n          var matches;\n          pattern.pattern.lastIndex = 0;\n\n          while (textLeft && (matches = pattern.pattern.exec(textLeft))) {\n            var previousText = textLeft.substr(0, matches.index);\n            indexOfMatchedString = matches.index;\n\n            if (++currentMatches > numberOfMatchesPermitted) {\n              break;\n            }\n\n            parts.push({\n              children: previousText\n            });\n            parts.push(_this.getMatchedPart(pattern, matches[0], matches, indexOfMatchedString));\n            textLeft = textLeft.substr(matches.index + matches[0].length);\n            indexOfMatchedString += matches[0].length - 1;\n            pattern.pattern.lastIndex = 0;\n          }\n\n          parts.push({\n            children: textLeft\n          });\n          newParts.push.apply(newParts, parts);\n        });\n        parsedTexts = newParts;\n      });\n      parsedTexts.forEach(function (parsedText) {\n        return delete parsedText._matched;\n      });\n      return parsedTexts.filter(function (t) {\n        return !!t.children;\n      });\n    }\n  }, {\n    key: \"getMatchedPart\",\n    value: function getMatchedPart(matchedPattern, text, matches, index) {\n      var props = {};\n      Object.keys(matchedPattern).forEach(function (key) {\n        if (key === 'pattern' || key === 'renderText' || key === 'nonExhaustiveModeMaxMatchCount') {\n          return;\n        }\n\n        if (typeof matchedPattern[key] === 'function') {\n          props[key] = function () {\n            return matchedPattern[key](text, index);\n          };\n        } else {\n          props[key] = matchedPattern[key];\n        }\n      });\n      var children = text;\n\n      if (matchedPattern.renderText && typeof matchedPattern.renderText === 'function') {\n        children = matchedPattern.renderText(text, matches);\n      }\n\n      return _objectSpread(_objectSpread({}, props), {}, {\n        children: children,\n        _matched: true\n      });\n    }\n  }]);\n\n  return TextExtraction;\n}();\n\nexport default TextExtraction;","map":{"version":3,"sources":["C:/Users/codetribe/Documents/GitHub/moveapp/awesomeproject/node_modules/react-native-parsed-text/src/lib/TextExtraction.js"],"names":["TextExtraction","text","patterns","parsedTexts","children","forEach","pattern","newParts","tmp","nonExhaustiveModeMaxMatchCount","numberOfMatchesPermitted","Math","min","max","Number","isInteger","POSITIVE_INFINITY","currentMatches","parsedText","_matched","push","parts","textLeft","indexOfMatchedString","matches","lastIndex","exec","previousText","substr","index","getMatchedPart","length","filter","t","matchedPattern","props","Object","keys","key","renderText"],"mappings":"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","sourcesContent":["/**\r\n * If you want to provide a custom regexp, this is the configuration to use.\r\n * -- For historical reasons, all regexps are processed as if they have the global flag set.\r\n * -- Use the nonExhaustiveModeMaxMatchCount property to match a limited number of matches.\r\n * Note: any additional keys/props are permitted, and will be returned as-is!\r\n * @typedef {Object} CustomParseShape\r\n * @property {RegExp} pattern\r\n * @property {number} [nonExhaustiveModeMaxMatchCount] Enables \"non-exhaustive mode\", where you can limit how many matches are found. -- Must be a positive integer or Infinity matches are permitted\r\n * @property {Function} [renderText] arbitrary function to rewrite the matched string into something else\r\n * @property {Function} [onPress]\r\n * @property {Function} [onLongPress]\r\n */\r\n/**\r\n * Class to encapsulate the business logic of converting text into matches & props\r\n */\r\nclass TextExtraction {\r\n  /**\r\n   * @param {String} text - Text to be parsed\r\n   * @param {CustomParseShape[]} patterns - Patterns to be used when parsed,\r\n   *                                 any extra attributes, will be returned from parse()\r\n   */\r\n  constructor(text, patterns) {\r\n    this.text = text;\r\n    this.patterns = patterns || [];\r\n  }\r\n\r\n  /**\r\n   * Returns parts of the text with their own props\r\n   * @public\r\n   * @return {Object[]} - props for all the parts of the text\r\n   */\r\n  parse() {\r\n    let parsedTexts = [{ children: this.text }];\r\n    this.patterns.forEach((pattern) => {\r\n      let newParts = [];\r\n\r\n      const tmp = pattern.nonExhaustiveModeMaxMatchCount || 0;\r\n      const numberOfMatchesPermitted = Math.min(\r\n        Math.max(Number.isInteger(tmp) ? tmp : 0, 0) ||\r\n          Number.POSITIVE_INFINITY,\r\n        Number.POSITIVE_INFINITY,\r\n      );\r\n\r\n      let currentMatches = 0;\r\n\r\n      parsedTexts.forEach((parsedText) => {\r\n        // Only allow for now one parsing\r\n        if (parsedText._matched) {\r\n          newParts.push(parsedText);\r\n          return;\r\n        }\r\n\r\n        let parts = [];\r\n        let textLeft = parsedText.children;\r\n        let indexOfMatchedString = 0;\r\n\r\n        /** @type {RegExpExecArray} */\r\n        let matches;\r\n        // Global RegExps are stateful, this makes it start at 0 if reused\r\n        // https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/RegExp/exec\r\n        pattern.pattern.lastIndex = 0;\r\n        while (textLeft && (matches = pattern.pattern.exec(textLeft))) {\r\n          let previousText = textLeft.substr(0, matches.index);\r\n          indexOfMatchedString = matches.index;\r\n\r\n          if (++currentMatches > numberOfMatchesPermitted) {\r\n            // Abort if we've exhausted our number of matches\r\n            break;\r\n          }\r\n\r\n          parts.push({ children: previousText });\r\n\r\n          parts.push(\r\n            this.getMatchedPart(\r\n              pattern,\r\n              matches[0],\r\n              matches,\r\n              indexOfMatchedString,\r\n            ),\r\n          );\r\n\r\n          textLeft = textLeft.substr(matches.index + matches[0].length);\r\n          indexOfMatchedString += matches[0].length - 1;\r\n          // Global RegExps are stateful, this makes it operate on the \"remainder\" of the string\r\n          pattern.pattern.lastIndex = 0;\r\n        }\r\n\r\n        parts.push({ children: textLeft });\r\n\r\n        newParts.push(...parts);\r\n      });\r\n\r\n      parsedTexts = newParts;\r\n    });\r\n\r\n    // Remove _matched key.\r\n    parsedTexts.forEach((parsedText) => delete parsedText._matched);\r\n\r\n    return parsedTexts.filter((t) => !!t.children);\r\n  }\r\n\r\n  // private\r\n\r\n  /**\r\n   * @protected\r\n   * @param {ParseShape} matchedPattern - pattern configuration of the pattern used to match the text\r\n   * @param {String} text - Text matching the pattern\r\n   * @param {String[]} matches - Result of the RegExp.exec\r\n   * @param {Integer} index - Index of the matched string in the whole string\r\n   * @return {Object} props for the matched text\r\n   */\r\n  getMatchedPart(matchedPattern, text, matches, index) {\r\n    let props = {};\r\n\r\n    Object.keys(matchedPattern).forEach((key) => {\r\n      if (\r\n        key === 'pattern' ||\r\n        key === 'renderText' ||\r\n        key === 'nonExhaustiveModeMaxMatchCount'\r\n      ) {\r\n        return;\r\n      }\r\n\r\n      if (typeof matchedPattern[key] === 'function') {\r\n        // Support onPress / onLongPress functions\r\n        props[key] = () => matchedPattern[key](text, index);\r\n      } else {\r\n        // Set a prop with an arbitrary name to the value in the match-config\r\n        props[key] = matchedPattern[key];\r\n      }\r\n    });\r\n\r\n    let children = text;\r\n    if (\r\n      matchedPattern.renderText &&\r\n      typeof matchedPattern.renderText === 'function'\r\n    ) {\r\n      children = matchedPattern.renderText(text, matches);\r\n    }\r\n\r\n    return {\r\n      ...props,\r\n      children: children,\r\n      _matched: true,\r\n    };\r\n  }\r\n}\r\n\r\nexport default TextExtraction;\r\n"]},"metadata":{},"sourceType":"module"}