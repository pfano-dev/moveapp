{"ast":null,"code":"import _objectWithoutProperties from \"@babel/runtime/helpers/objectWithoutProperties\";\nimport _classCallCheck from \"@babel/runtime/helpers/classCallCheck\";\nimport _createClass from \"@babel/runtime/helpers/createClass\";\nimport _inherits from \"@babel/runtime/helpers/inherits\";\nimport _possibleConstructorReturn from \"@babel/runtime/helpers/possibleConstructorReturn\";\nimport _getPrototypeOf from \"@babel/runtime/helpers/getPrototypeOf\";\nimport _defineProperty from \"@babel/runtime/helpers/defineProperty\";\nvar _excluded = [\"type\"],\n    _excluded2 = [\"style\"],\n    _excluded3 = [\"parse\", \"childrenProps\"];\n\nfunction _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }\n\nfunction _isNativeReflectConstruct() { if (typeof Reflect === \"undefined\" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === \"function\") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }\n\nfunction ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }\n\nfunction _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? ownKeys(Object(source), !0).forEach(function (key) { _defineProperty(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }\n\nimport React from 'react';\nimport Text from \"react-native-web/dist/exports/Text\";\nimport PropTypes from 'prop-types';\nimport TextExtraction from \"./lib/TextExtraction\";\nimport { jsx as _jsx } from \"react/jsx-runtime\";\nexport var PATTERNS = {\n  url: /(https?:\\/\\/|www\\.)[-a-zA-Z0-9@:%._\\+~#=]{1,256}\\.(xn--)?[a-z0-9-]{2,20}\\b([-a-zA-Z0-9@:%_\\+\\[\\],.~#?&\\/=]*[-a-zA-Z0-9@:%_\\+\\]~#?&\\/=])*/i,\n  phone: /[\\+]?[(]?[0-9]{3}[)]?[-\\s\\.]?[0-9]{3}[-\\s\\.]?[0-9]{4,7}/,\n  email: /\\S+@\\S+\\.\\S+/\n};\nvar defaultParseShape = PropTypes.shape(_objectSpread(_objectSpread({}, Text.propTypes), {}, {\n  type: PropTypes.oneOf(Object.keys(PATTERNS)).isRequired,\n  nonExhaustiveMaxMatchCount: PropTypes.number\n}));\nvar customParseShape = PropTypes.shape(_objectSpread(_objectSpread({}, Text.propTypes), {}, {\n  pattern: PropTypes.oneOfType([PropTypes.string, PropTypes.instanceOf(RegExp)]).isRequired,\n  nonExhaustiveMaxMatchCount: PropTypes.number\n}));\n\nvar ParsedText = function (_React$Component) {\n  _inherits(ParsedText, _React$Component);\n\n  var _super = _createSuper(ParsedText);\n\n  function ParsedText() {\n    _classCallCheck(this, ParsedText);\n\n    return _super.apply(this, arguments);\n  }\n\n  _createClass(ParsedText, [{\n    key: \"setNativeProps\",\n    value: function setNativeProps(nativeProps) {\n      this._root.setNativeProps(nativeProps);\n    }\n  }, {\n    key: \"getPatterns\",\n    value: function getPatterns() {\n      return this.props.parse.map(function (option) {\n        var type = option.type,\n            patternOption = _objectWithoutProperties(option, _excluded);\n\n        if (type) {\n          if (!PATTERNS[type]) {\n            throw new Error(option.type + \" is not a supported type\");\n          }\n\n          patternOption.pattern = PATTERNS[type];\n        }\n\n        return patternOption;\n      });\n    }\n  }, {\n    key: \"getParsedText\",\n    value: function getParsedText() {\n      var _this = this;\n\n      if (!this.props.parse) {\n        return this.props.children;\n      }\n\n      if (typeof this.props.children !== 'string') {\n        return this.props.children;\n      }\n\n      var textExtraction = new TextExtraction(this.props.children, this.getPatterns());\n      return textExtraction.parse().map(function (props, index) {\n        var parentStyle = _this.props.style;\n\n        var style = props.style,\n            remainder = _objectWithoutProperties(props, _excluded2);\n\n        return _jsx(Text, _objectSpread(_objectSpread({\n          style: [parentStyle, style]\n        }, _this.props.childrenProps), remainder), \"parsedText-\" + index);\n      });\n    }\n  }, {\n    key: \"render\",\n    value: function render() {\n      var _this2 = this;\n\n      var _this$props = _objectSpread({}, this.props),\n          parse = _this$props.parse,\n          childrenProps = _this$props.childrenProps,\n          remainder = _objectWithoutProperties(_this$props, _excluded3);\n\n      return _jsx(Text, _objectSpread(_objectSpread({\n        ref: function ref(_ref) {\n          return _this2._root = _ref;\n        }\n      }, remainder), {}, {\n        children: this.getParsedText()\n      }));\n    }\n  }]);\n\n  return ParsedText;\n}(React.Component);\n\nParsedText.displayName = 'ParsedText';\nParsedText.propTypes = _objectSpread(_objectSpread({}, Text.propTypes), {}, {\n  parse: PropTypes.arrayOf(PropTypes.oneOfType([defaultParseShape, customParseShape])),\n  childrenProps: PropTypes.shape(Text.propTypes)\n});\nParsedText.defaultProps = {\n  parse: null,\n  childrenProps: {}\n};\nexport default ParsedText;","map":{"version":3,"sources":["C:/Users/codetribe/Documents/GitHub/moveapp/awesomeproject/node_modules/react-native-parsed-text/src/ParsedText.js"],"names":["React","PropTypes","TextExtraction","PATTERNS","url","phone","email","defaultParseShape","shape","Text","propTypes","type","oneOf","Object","keys","isRequired","nonExhaustiveMaxMatchCount","number","customParseShape","pattern","oneOfType","string","instanceOf","RegExp","ParsedText","nativeProps","_root","setNativeProps","props","parse","map","option","patternOption","Error","children","textExtraction","getPatterns","index","parentStyle","style","remainder","childrenProps","ref","getParsedText","Component","displayName","arrayOf","defaultProps"],"mappings":"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","sourcesContent":["import React from 'react';\r\nimport { Text } from 'react-native';\r\nimport PropTypes from 'prop-types';\r\n\r\nimport TextExtraction from './lib/TextExtraction';\r\n\r\n/**\r\n * This is a list of the known patterns that are provided by this library\r\n * @typedef {('url'|'phone'|'email')} KnownParsePattern\r\n */\r\n/**\r\n * @type {Object.<string, RegExp>}\r\n * // The keys really should be KnownParsePattern -- but this is unsupported in jsdoc, sadly\r\n */\r\nexport const PATTERNS = {\r\n  /**\r\n   * Segments/Features:\r\n   *  - http/https support https?\r\n   *  - auto-detecting loose domains if preceded by `www.`\r\n   *  - Localized & Long top-level domains \\.(xn--)?[a-z0-9-]{2,20}\\b\r\n   *  - Allowed query parameters & values, it's two blocks of matchers\r\n   *    ([-a-zA-Z0-9@:%_\\+,.~#?&\\/=]*[-a-zA-Z0-9@:%_\\+~#?&\\/=])*\r\n   *    - First block is [-a-zA-Z0-9@:%_\\+\\[\\],.~#?&\\/=]* -- this matches parameter names & values (including commas, dots, opening & closing brackets)\r\n   *    - The first block must be followed by a closing block [-a-zA-Z0-9@:%_\\+\\]~#?&\\/=] -- this doesn't match commas, dots, and opening brackets\r\n   */\r\n  url: /(https?:\\/\\/|www\\.)[-a-zA-Z0-9@:%._\\+~#=]{1,256}\\.(xn--)?[a-z0-9-]{2,20}\\b([-a-zA-Z0-9@:%_\\+\\[\\],.~#?&\\/=]*[-a-zA-Z0-9@:%_\\+\\]~#?&\\/=])*/i,\r\n  phone: /[\\+]?[(]?[0-9]{3}[)]?[-\\s\\.]?[0-9]{3}[-\\s\\.]?[0-9]{4,7}/,\r\n  email: /\\S+@\\S+\\.\\S+/,\r\n};\r\n\r\n/**\r\n * This is for built-in-patterns already supported by this library\r\n * Note: any additional keys/props are permitted, and will be passed along as props to the <Text> component!\r\n * @typedef {Object} DefaultParseShape\r\n * @property {KnownParsePattern} [type] key of the known pattern you'd like to configure\r\n * @property {number} [nonExhaustiveModeMaxMatchCount] Enables \"non-exhaustive mode\", where you can limit how many matches are found. -- Must be a positive integer or Infinity matches are permitted\r\n * @property {Function} [renderText] arbitrary function to rewrite the matched string into something else\r\n * @property {Function} [onPress]\r\n * @property {Function} [onLongPress]\r\n */\r\nconst defaultParseShape = PropTypes.shape({\r\n  ...Text.propTypes,\r\n  type: PropTypes.oneOf(Object.keys(PATTERNS)).isRequired,\r\n  nonExhaustiveMaxMatchCount: PropTypes.number,\r\n});\r\n\r\nconst customParseShape = PropTypes.shape({\r\n  ...Text.propTypes,\r\n  pattern: PropTypes.oneOfType([PropTypes.string, PropTypes.instanceOf(RegExp)])\r\n    .isRequired,\r\n  nonExhaustiveMaxMatchCount: PropTypes.number,\r\n});\r\n\r\n/**\r\n * The props added by this component\r\n * @typedef {DefaultParseShape|import('./lib/TextExtraction').CustomParseShape} ParsedTextAddedProps\r\n * @property {ParseShape[]} parse\r\n * @property {import('react-native').TextProps} childrenProps -- the props set on each child Text component\r\n */\r\n/** @typedef {ParsedTextAddedProps & import('react-native').TextProps} ParsedTextProps */\r\n\r\n/** @type {import('react').ComponentClass<ParsedTextProps>} */\r\nclass ParsedText extends React.Component {\r\n  static displayName = 'ParsedText';\r\n\r\n  static propTypes = {\r\n    ...Text.propTypes,\r\n    parse: PropTypes.arrayOf(\r\n      PropTypes.oneOfType([defaultParseShape, customParseShape]),\r\n    ),\r\n    childrenProps: PropTypes.shape(Text.propTypes),\r\n  };\r\n\r\n  static defaultProps = {\r\n    parse: null,\r\n    childrenProps: {},\r\n  };\r\n\r\n  setNativeProps(nativeProps) {\r\n    this._root.setNativeProps(nativeProps);\r\n  }\r\n  /** @returns {import('./lib/TextExtraction').CustomParseShape[]} */\r\n  getPatterns() {\r\n    return this.props.parse.map((option) => {\r\n      const { type, ...patternOption } = option;\r\n      if (type) {\r\n        if (!PATTERNS[type]) {\r\n          throw new Error(`${option.type} is not a supported type`);\r\n        }\r\n        patternOption.pattern = PATTERNS[type];\r\n      }\r\n\r\n      return patternOption;\r\n    });\r\n  }\r\n\r\n  getParsedText() {\r\n    if (!this.props.parse) {\r\n      return this.props.children;\r\n    }\r\n    if (typeof this.props.children !== 'string') {\r\n      return this.props.children;\r\n    }\r\n\r\n    const textExtraction = new TextExtraction(\r\n      this.props.children,\r\n      this.getPatterns(),\r\n    );\r\n\r\n    return textExtraction.parse().map((props, index) => {\r\n      const { style: parentStyle } = this.props;\r\n      const { style, ...remainder } = props;\r\n      return (\r\n        <Text\r\n          key={`parsedText-${index}`}\r\n          style={[parentStyle, style]}\r\n          {...this.props.childrenProps}\r\n          {...remainder}\r\n        />\r\n      );\r\n    });\r\n  }\r\n\r\n  render() {\r\n    // Discard custom props before passing remainder to Text\r\n    const { parse, childrenProps, ...remainder } = { ...this.props };\r\n\r\n    return (\r\n      <Text ref={(ref) => (this._root = ref)} {...remainder}>\r\n        {this.getParsedText()}\r\n      </Text>\r\n    );\r\n  }\r\n}\r\n\r\nexport default ParsedText;\r\n"]},"metadata":{},"sourceType":"module"}