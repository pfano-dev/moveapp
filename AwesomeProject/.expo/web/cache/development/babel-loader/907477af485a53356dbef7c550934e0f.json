{"ast":null,"code":"import _defineProperty from \"@babel/runtime/helpers/defineProperty\";\nimport _objectWithoutProperties from \"@babel/runtime/helpers/objectWithoutProperties\";\nimport _toConsumableArray from \"@babel/runtime/helpers/toConsumableArray\";\nimport _classCallCheck from \"@babel/runtime/helpers/classCallCheck\";\nimport _createClass from \"@babel/runtime/helpers/createClass\";\nimport _inherits from \"@babel/runtime/helpers/inherits\";\nimport _possibleConstructorReturn from \"@babel/runtime/helpers/possibleConstructorReturn\";\nimport _getPrototypeOf from \"@babel/runtime/helpers/getPrototypeOf\";\nvar _excluded = [\"origin\", \"waypoints\", \"splitWaypoints\", \"destination\", \"apikey\", \"onReady\", \"onError\", \"mode\", \"language\", \"region\", \"precision\"];\n\nfunction ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }\n\nfunction _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? ownKeys(Object(source), !0).forEach(function (key) { _defineProperty(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }\n\nfunction _createForOfIteratorHelperLoose(o, allowArrayLike) { var it = typeof Symbol !== \"undefined\" && o[Symbol.iterator] || o[\"@@iterator\"]; if (it) return (it = it.call(o)).next.bind(it); if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === \"number\") { if (it) o = it; var i = 0; return function () { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }; } throw new TypeError(\"Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); }\n\nfunction _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === \"string\") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === \"Object\" && o.constructor) n = o.constructor.name; if (n === \"Map\" || n === \"Set\") return Array.from(o); if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }\n\nfunction _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }\n\nfunction _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }\n\nfunction _isNativeReflectConstruct() { if (typeof Reflect === \"undefined\" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === \"function\") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }\n\nimport React, { Component } from 'react';\nimport PropTypes from 'prop-types';\nimport MapView from 'react-native-maps';\nimport isEqual from 'lodash.isequal';\nimport { jsx as _jsx } from \"react/jsx-runtime\";\nvar WAYPOINT_LIMIT = 10;\n\nvar MapViewDirections = function (_Component) {\n  _inherits(MapViewDirections, _Component);\n\n  var _super = _createSuper(MapViewDirections);\n\n  function MapViewDirections(_props) {\n    var _this;\n\n    _classCallCheck(this, MapViewDirections);\n\n    _this = _super.call(this, _props);\n\n    _this.resetState = function () {\n      var cb = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;\n\n      _this.setState({\n        coordinates: null,\n        distance: null,\n        duration: null\n      }, cb);\n    };\n\n    _this.fetchAndRenderRoute = function (props) {\n      var initialOrigin = props.origin,\n          initialDestination = props.destination,\n          _props$waypoints = props.waypoints,\n          initialWaypoints = _props$waypoints === void 0 ? [] : _props$waypoints,\n          apikey = props.apikey,\n          onStart = props.onStart,\n          onReady = props.onReady,\n          onError = props.onError,\n          _props$mode = props.mode,\n          mode = _props$mode === void 0 ? 'DRIVING' : _props$mode,\n          _props$language = props.language,\n          language = _props$language === void 0 ? 'en' : _props$language,\n          optimizeWaypoints = props.optimizeWaypoints,\n          splitWaypoints = props.splitWaypoints,\n          _props$directionsServ = props.directionsServiceBaseUrl,\n          directionsServiceBaseUrl = _props$directionsServ === void 0 ? 'https://maps.googleapis.com/maps/api/directions/json' : _props$directionsServ,\n          region = props.region,\n          _props$precision = props.precision,\n          precision = _props$precision === void 0 ? 'low' : _props$precision,\n          _props$timePrecision = props.timePrecision,\n          timePrecision = _props$timePrecision === void 0 ? 'none' : _props$timePrecision,\n          channel = props.channel;\n\n      if (!apikey) {\n        console.warn(\"MapViewDirections Error: Missing API Key\");\n        return;\n      }\n\n      if (!initialOrigin || !initialDestination) {\n        return;\n      }\n\n      var timePrecisionString = timePrecision === 'none' ? '' : timePrecision;\n      var routes = [];\n\n      if (splitWaypoints && initialWaypoints && initialWaypoints.length > WAYPOINT_LIMIT) {\n        var chunckedWaypoints = initialWaypoints.reduce(function (accumulator, waypoint, index) {\n          var numChunk = Math.floor(index / WAYPOINT_LIMIT);\n          accumulator[numChunk] = [].concat(accumulator[numChunk] || [], waypoint);\n          return accumulator;\n        }, []);\n\n        for (var i = 0; i < chunckedWaypoints.length; i++) {\n          routes.push({\n            waypoints: chunckedWaypoints[i],\n            origin: i === 0 ? initialOrigin : chunckedWaypoints[i - 1][chunckedWaypoints[i - 1].length - 1],\n            destination: i === chunckedWaypoints.length - 1 ? initialDestination : chunckedWaypoints[i + 1][0]\n          });\n        }\n      } else {\n        routes.push({\n          waypoints: initialWaypoints,\n          origin: initialOrigin,\n          destination: initialDestination\n        });\n      }\n\n      Promise.all(routes.map(function (route, index) {\n        var origin = route.origin,\n            destination = route.destination,\n            waypoints = route.waypoints;\n\n        if (origin.latitude && origin.longitude) {\n          origin = origin.latitude + \",\" + origin.longitude;\n        }\n\n        if (destination.latitude && destination.longitude) {\n          destination = destination.latitude + \",\" + destination.longitude;\n        }\n\n        waypoints = waypoints.map(function (waypoint) {\n          return waypoint.latitude && waypoint.longitude ? waypoint.latitude + \",\" + waypoint.longitude : waypoint;\n        }).join('|');\n\n        if (optimizeWaypoints) {\n          waypoints = \"optimize:true|\" + waypoints;\n        }\n\n        if (index === 0) {\n          onStart && onStart({\n            origin: origin,\n            destination: destination,\n            waypoints: initialWaypoints\n          });\n        }\n\n        return _this.fetchRoute(directionsServiceBaseUrl, origin, waypoints, destination, apikey, mode, language, region, precision, timePrecisionString, channel).then(function (result) {\n          return result;\n        }).catch(function (errorMessage) {\n          return Promise.reject(errorMessage);\n        });\n      })).then(function (results) {\n        var result = results.reduce(function (acc, _ref) {\n          var distance = _ref.distance,\n              duration = _ref.duration,\n              coordinates = _ref.coordinates,\n              fare = _ref.fare,\n              waypointOrder = _ref.waypointOrder;\n          acc.coordinates = [].concat(_toConsumableArray(acc.coordinates), _toConsumableArray(coordinates));\n          acc.distance += distance;\n          acc.duration += duration;\n          acc.fares = [].concat(_toConsumableArray(acc.fares), [fare]);\n          acc.waypointOrder = [].concat(_toConsumableArray(acc.waypointOrder), [waypointOrder]);\n          return acc;\n        }, {\n          coordinates: [],\n          distance: 0,\n          duration: 0,\n          fares: [],\n          waypointOrder: []\n        });\n\n        _this.setState({\n          coordinates: result.coordinates\n        }, function () {\n          if (onReady) {\n            onReady(result);\n          }\n        });\n      }).catch(function (errorMessage) {\n        _this.resetState();\n\n        console.warn(\"MapViewDirections Error: \" + errorMessage);\n        onError && onError(errorMessage);\n      });\n    };\n\n    _this.state = {\n      coordinates: null,\n      distance: null,\n      duration: null\n    };\n    return _this;\n  }\n\n  _createClass(MapViewDirections, [{\n    key: \"componentDidMount\",\n    value: function componentDidMount() {\n      this.fetchAndRenderRoute(this.props);\n    }\n  }, {\n    key: \"componentDidUpdate\",\n    value: function componentDidUpdate(prevProps) {\n      var _this2 = this;\n\n      if (!isEqual(prevProps.origin, this.props.origin) || !isEqual(prevProps.destination, this.props.destination) || !isEqual(prevProps.waypoints, this.props.waypoints) || !isEqual(prevProps.mode, this.props.mode) || !isEqual(prevProps.precision, this.props.precision) || !isEqual(prevProps.splitWaypoints, this.props.splitWaypoints)) {\n        if (this.props.resetOnChange === false) {\n          this.fetchAndRenderRoute(this.props);\n        } else {\n          this.resetState(function () {\n            _this2.fetchAndRenderRoute(_this2.props);\n          });\n        }\n      }\n    }\n  }, {\n    key: \"decode\",\n    value: function decode(t) {\n      var points = [];\n\n      for (var _iterator = _createForOfIteratorHelperLoose(t), _step; !(_step = _iterator()).done;) {\n        var step = _step.value;\n        var encoded = step.polyline.points;\n        var index = 0,\n            len = encoded.length;\n        var lat = 0,\n            lng = 0;\n\n        while (index < len) {\n          var b = void 0,\n              shift = 0,\n              result = 0;\n\n          do {\n            b = encoded.charAt(index++).charCodeAt(0) - 63;\n            result |= (b & 0x1f) << shift;\n            shift += 5;\n          } while (b >= 0x20);\n\n          var dlat = (result & 1) != 0 ? ~(result >> 1) : result >> 1;\n          lat += dlat;\n          shift = 0;\n          result = 0;\n\n          do {\n            b = encoded.charAt(index++).charCodeAt(0) - 63;\n            result |= (b & 0x1f) << shift;\n            shift += 5;\n          } while (b >= 0x20);\n\n          var dlng = (result & 1) != 0 ? ~(result >> 1) : result >> 1;\n          lng += dlng;\n          points.push({\n            latitude: lat / 1E5,\n            longitude: lng / 1E5\n          });\n        }\n      }\n\n      return points;\n    }\n  }, {\n    key: \"fetchRoute\",\n    value: function fetchRoute(directionsServiceBaseUrl, origin, waypoints, destination, apikey, mode, language, region, precision, timePrecision, channel) {\n      var _this3 = this;\n\n      var url = directionsServiceBaseUrl;\n\n      if (typeof directionsServiceBaseUrl === 'string') {\n        url += \"?origin=\" + origin + \"&waypoints=\" + waypoints + \"&destination=\" + destination + \"&key=\" + apikey + \"&mode=\" + mode.toLowerCase() + \"&language=\" + language + \"&region=\" + region;\n\n        if (timePrecision) {\n          url += \"&departure_time=\" + timePrecision;\n        }\n\n        if (channel) {\n          url += \"&channel=\" + channel;\n        }\n      }\n\n      return fetch(url).then(function (response) {\n        return response.json();\n      }).then(function (json) {\n        if (json.status !== 'OK') {\n          var errorMessage = json.error_message || json.status || 'Unknown error';\n          return Promise.reject(errorMessage);\n        }\n\n        if (json.routes.length) {\n          var route = json.routes[0];\n          return Promise.resolve({\n            distance: route.legs.reduce(function (carry, curr) {\n              return carry + curr.distance.value;\n            }, 0) / 1000,\n            duration: route.legs.reduce(function (carry, curr) {\n              return carry + (curr.duration_in_traffic ? curr.duration_in_traffic.value : curr.duration.value);\n            }, 0) / 60,\n            coordinates: precision === 'low' ? _this3.decode([{\n              polyline: route.overview_polyline\n            }]) : route.legs.reduce(function (carry, curr) {\n              return [].concat(_toConsumableArray(carry), _toConsumableArray(_this3.decode(curr.steps)));\n            }, []),\n            fare: route.fare,\n            waypointOrder: route.waypoint_order\n          });\n        } else {\n          return Promise.reject();\n        }\n      }).catch(function (err) {\n        return Promise.reject(\"Error on GMAPS route request: \" + err);\n      });\n    }\n  }, {\n    key: \"render\",\n    value: function render() {\n      var coordinates = this.state.coordinates;\n\n      if (!coordinates) {\n        return null;\n      }\n\n      var _this$props = this.props,\n          origin = _this$props.origin,\n          waypoints = _this$props.waypoints,\n          splitWaypoints = _this$props.splitWaypoints,\n          destination = _this$props.destination,\n          apikey = _this$props.apikey,\n          onReady = _this$props.onReady,\n          onError = _this$props.onError,\n          mode = _this$props.mode,\n          language = _this$props.language,\n          region = _this$props.region,\n          precision = _this$props.precision,\n          props = _objectWithoutProperties(_this$props, _excluded);\n\n      return _jsx(MapView.Polyline, _objectSpread({\n        coordinates: coordinates\n      }, props));\n    }\n  }]);\n\n  return MapViewDirections;\n}(Component);\n\nMapViewDirections.propTypes = {\n  origin: PropTypes.oneOfType([PropTypes.string, PropTypes.shape({\n    latitude: PropTypes.number.isRequired,\n    longitude: PropTypes.number.isRequired\n  })]),\n  waypoints: PropTypes.arrayOf(PropTypes.oneOfType([PropTypes.string, PropTypes.shape({\n    latitude: PropTypes.number.isRequired,\n    longitude: PropTypes.number.isRequired\n  })])),\n  destination: PropTypes.oneOfType([PropTypes.string, PropTypes.shape({\n    latitude: PropTypes.number.isRequired,\n    longitude: PropTypes.number.isRequired\n  })]),\n  apikey: PropTypes.string.isRequired,\n  onStart: PropTypes.func,\n  onReady: PropTypes.func,\n  onError: PropTypes.func,\n  mode: PropTypes.oneOf(['DRIVING', 'BICYCLING', 'TRANSIT', 'WALKING']),\n  language: PropTypes.string,\n  resetOnChange: PropTypes.bool,\n  optimizeWaypoints: PropTypes.bool,\n  splitWaypoints: PropTypes.bool,\n  directionsServiceBaseUrl: PropTypes.string,\n  region: PropTypes.string,\n  precision: PropTypes.oneOf(['high', 'low']),\n  timePrecision: PropTypes.oneOf(['now', 'none']),\n  channel: PropTypes.string\n};\nexport default MapViewDirections;","map":{"version":3,"sources":["C:/Users/codetribe/Documents/GitHub/moveapp/awesomeproject/node_modules/react-native-maps-directions/src/MapViewDirections.js"],"names":["React","Component","PropTypes","MapView","isEqual","WAYPOINT_LIMIT","MapViewDirections","props","resetState","cb","setState","coordinates","distance","duration","fetchAndRenderRoute","initialOrigin","origin","initialDestination","destination","waypoints","initialWaypoints","apikey","onStart","onReady","onError","mode","language","optimizeWaypoints","splitWaypoints","directionsServiceBaseUrl","region","precision","timePrecision","channel","console","warn","timePrecisionString","routes","length","chunckedWaypoints","reduce","accumulator","waypoint","index","numChunk","Math","floor","concat","i","push","Promise","all","map","route","latitude","longitude","join","fetchRoute","then","result","catch","errorMessage","reject","results","acc","fare","waypointOrder","fares","state","prevProps","resetOnChange","t","points","step","encoded","polyline","len","lat","lng","b","shift","charAt","charCodeAt","dlat","dlng","url","toLowerCase","fetch","response","json","status","error_message","resolve","legs","carry","curr","value","duration_in_traffic","decode","overview_polyline","steps","waypoint_order","err","propTypes","oneOfType","string","shape","number","isRequired","arrayOf","func","oneOf","bool"],"mappings":"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","sourcesContent":["import React, { Component } from 'react';\r\nimport PropTypes from 'prop-types';\r\nimport MapView from 'react-native-maps';\r\nimport isEqual from 'lodash.isequal';\r\n\r\nconst WAYPOINT_LIMIT = 10;\r\n\r\nclass MapViewDirections extends Component {\r\n\r\n\tconstructor(props) {\r\n\t\tsuper(props);\r\n\r\n\t\tthis.state = {\r\n\t\t\tcoordinates: null,\r\n\t\t\tdistance: null,\r\n\t\t\tduration: null,\r\n\t\t};\r\n\t}\r\n\r\n\tcomponentDidMount() {\r\n\t\tthis.fetchAndRenderRoute(this.props);\r\n\t}\r\n\r\n\tcomponentDidUpdate(prevProps) {\r\n\t\tif (!isEqual(prevProps.origin, this.props.origin) || !isEqual(prevProps.destination, this.props.destination) || !isEqual(prevProps.waypoints, this.props.waypoints) || !isEqual(prevProps.mode, this.props.mode) || !isEqual(prevProps.precision, this.props.precision) || !isEqual(prevProps.splitWaypoints, this.props.splitWaypoints)) {\r\n\t\t\tif (this.props.resetOnChange === false) {\r\n\t\t\t\tthis.fetchAndRenderRoute(this.props);\r\n\t\t\t} else {\r\n\t\t\t\tthis.resetState(() => {\r\n\t\t\t\t\tthis.fetchAndRenderRoute(this.props);\r\n\t\t\t\t});\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\r\n\tresetState = (cb = null) => {\r\n\t\tthis.setState({\r\n\t\t\tcoordinates: null,\r\n\t\t\tdistance: null,\r\n\t\t\tduration: null,\r\n\t\t}, cb);\r\n\t}\r\n\r\n\tdecode(t) {\r\n\t\tlet points = [];\r\n\t\tfor (let step of t) {\r\n\t\t\tlet encoded = step.polyline.points;\r\n\t\t\tlet index = 0, len = encoded.length;\r\n\t\t\tlet lat = 0, lng = 0;\r\n\t\t\twhile (index < len) {\r\n\t\t\t\tlet b, shift = 0, result = 0;\r\n\t\t\t\tdo {\r\n\t\t\t\t\tb = encoded.charAt(index++).charCodeAt(0) - 63;\r\n\t\t\t\t\tresult |= (b & 0x1f) << shift;\r\n\t\t\t\t\tshift += 5;\r\n\t\t\t\t} while (b >= 0x20);\r\n\r\n\t\t\t\tlet dlat = ((result & 1) != 0 ? ~(result >> 1) : (result >> 1));\r\n\t\t\t\tlat += dlat;\r\n\t\t\t\tshift = 0;\r\n\t\t\t\tresult = 0;\r\n\t\t\t\tdo {\r\n\t\t\t\t\tb = encoded.charAt(index++).charCodeAt(0) - 63;\r\n\t\t\t\t\tresult |= (b & 0x1f) << shift;\r\n\t\t\t\t\tshift += 5;\r\n\t\t\t\t} while (b >= 0x20);\r\n\t\t\t\tlet dlng = ((result & 1) != 0 ? ~(result >> 1) : (result >> 1));\r\n\t\t\t\tlng += dlng;\r\n\r\n\t\t\t\tpoints.push({ latitude: (lat / 1E5), longitude: (lng / 1E5) });\r\n\t\t\t}\r\n\t\t}\r\n\t\treturn points;\r\n\t}\r\n\r\n\tfetchAndRenderRoute = (props) => {\r\n\r\n\t\tlet {\r\n\t\t\torigin: initialOrigin,\r\n\t\t\tdestination: initialDestination,\r\n\t\t\twaypoints: initialWaypoints = [],\r\n\t\t\tapikey,\r\n\t\t\tonStart,\r\n\t\t\tonReady,\r\n\t\t\tonError,\r\n\t\t\tmode = 'DRIVING',\r\n\t\t\tlanguage = 'en',\r\n\t\t\toptimizeWaypoints,\r\n\t\t\tsplitWaypoints,\r\n\t\t\tdirectionsServiceBaseUrl = 'https://maps.googleapis.com/maps/api/directions/json',\r\n\t\t\tregion,\r\n\t\t\tprecision = 'low',\r\n\t\t\ttimePrecision = 'none',\r\n\t\t\tchannel,\r\n\t\t} = props;\r\n\r\n\t\tif (!apikey) {\r\n\t\t\tconsole.warn(`MapViewDirections Error: Missing API Key`); // eslint-disable-line no-console\r\n\t\t\treturn;\r\n\t\t}\r\n\r\n\t\tif (!initialOrigin || !initialDestination) {\r\n\t\t\treturn;\r\n\t\t}\r\n\r\n\t\tconst timePrecisionString = timePrecision==='none' ? '' : timePrecision;\r\n\t\t\r\n\t\t// Routes array which we'll be filling.\r\n\t\t// We'll perform a Directions API Request for reach route\r\n\t\tconst routes = [];\r\n\r\n\t\t// We need to split the waypoints in chunks, in order to not exceede the max waypoint limit\r\n\t\t// ~> Chunk up the waypoints, yielding multiple routes\r\n\t\tif (splitWaypoints && initialWaypoints && initialWaypoints.length > WAYPOINT_LIMIT) {\r\n\t\t\t// Split up waypoints in chunks with chunksize WAYPOINT_LIMIT\r\n\t\t\tconst chunckedWaypoints = initialWaypoints.reduce((accumulator, waypoint, index) => {\r\n\t\t\t\tconst numChunk = Math.floor(index / WAYPOINT_LIMIT); \r\n\t\t\t\taccumulator[numChunk] = [].concat((accumulator[numChunk] || []), waypoint); \r\n\t\t\t\treturn accumulator;\r\n\t\t\t}, []);\r\n\r\n\t\t\t// Create routes for each chunk, using:\r\n\t\t\t// - Endpoints of previous chunks as startpoints for the route (except for the first chunk, which uses initialOrigin)\r\n\t\t\t// - Startpoints of next chunks as endpoints for the route (except for the last chunk, which uses initialDestination)\r\n\t\t\tfor (let i = 0; i < chunckedWaypoints.length; i++) {\r\n\t\t\t\troutes.push({\r\n\t\t\t\t\twaypoints: chunckedWaypoints[i],\r\n\t\t\t\t\torigin: (i === 0) ? initialOrigin : chunckedWaypoints[i-1][chunckedWaypoints[i-1].length - 1],\r\n\t\t\t\t\tdestination: (i === chunckedWaypoints.length - 1) ? initialDestination : chunckedWaypoints[i+1][0],\r\n\t\t\t\t});\r\n\t\t\t}\r\n\t\t}\r\n\t\t\r\n\t\t// No splitting of the waypoints is requested/needed.\r\n\t\t// ~> Use one single route\r\n\t\telse {\r\n\t\t\troutes.push({\r\n\t\t\t\twaypoints: initialWaypoints,\r\n\t\t\t\torigin: initialOrigin,\r\n\t\t\t\tdestination: initialDestination,\r\n\t\t\t});\r\n\t\t}\r\n\r\n\t\t// Perform a Directions API Request for each route\r\n\t\tPromise.all(routes.map((route, index) => {\r\n\t\t\tlet {\r\n\t\t\t\torigin,\r\n\t\t\t\tdestination,\r\n\t\t\t\twaypoints,\r\n\t\t\t} = route;\r\n\r\n\t\t\tif (origin.latitude && origin.longitude) {\r\n\t\t\t\torigin = `${origin.latitude},${origin.longitude}`;\r\n\t\t\t}\r\n\r\n\t\t\tif (destination.latitude && destination.longitude) {\r\n\t\t\t\tdestination = `${destination.latitude},${destination.longitude}`;\r\n\t\t\t}\r\n\r\n\t\t\twaypoints = waypoints\r\n\t\t\t\t.map(waypoint => (waypoint.latitude && waypoint.longitude) ? `${waypoint.latitude},${waypoint.longitude}` : waypoint)\r\n\t\t\t\t.join('|');\r\n\r\n\t\t\tif (optimizeWaypoints) {\r\n\t\t\t\twaypoints = `optimize:true|${waypoints}`;\r\n\t\t\t}\r\n\r\n\t\t\tif (index === 0) {\r\n\t\t\t\tonStart && onStart({\r\n\t\t\t\t\torigin,\r\n\t\t\t\t\tdestination,\r\n\t\t\t\t\twaypoints: initialWaypoints,\r\n\t\t\t\t});\r\n\t\t\t}\r\n\r\n\t\t\treturn (\r\n\t\t\t\tthis.fetchRoute(directionsServiceBaseUrl, origin, waypoints, destination, apikey, mode, language, region, precision, timePrecisionString, channel)\r\n\t\t\t\t\t.then(result => {\r\n\t\t\t\t\t\treturn result;\r\n\t\t\t\t\t})\r\n\t\t\t\t\t.catch(errorMessage => {\r\n\t\t\t\t\t\treturn Promise.reject(errorMessage);\r\n\t\t\t\t\t})\r\n\t\t\t);\r\n\t\t})).then(results => {\r\n\t\t\t// Combine all Directions API Request results into one\r\n\t\t\tconst result = results.reduce((acc, { distance, duration, coordinates, fare, waypointOrder }) => {\r\n\t\t\t\tacc.coordinates = [\r\n\t\t\t\t\t...acc.coordinates,\r\n\t\t\t\t\t...coordinates,\r\n\t\t\t\t];\r\n\t\t\t\tacc.distance += distance;\r\n\t\t\t\tacc.duration += duration;\r\n\t\t\t\tacc.fares = [\r\n\t\t\t\t\t...acc.fares,\r\n\t\t\t\t\tfare,\r\n\t\t\t\t];\r\n\t\t\t\tacc.waypointOrder = [\r\n\t\t\t\t\t...acc.waypointOrder,\r\n\t\t\t\t\twaypointOrder,\r\n\t\t\t\t];\r\n\r\n\t\t\t\treturn acc;\r\n\t\t\t}, {\r\n\t\t\t\tcoordinates: [],\r\n\t\t\t\tdistance: 0,\r\n\t\t\t\tduration: 0,\r\n\t\t\t\tfares: [],\r\n\t\t\t\twaypointOrder: [],\r\n\t\t\t});\r\n\r\n\t\t\t// Plot it out and call the onReady callback\r\n\t\t\tthis.setState({\r\n\t\t\t\tcoordinates: result.coordinates,\r\n\t\t\t}, function() {\r\n\t\t\t\tif (onReady) {\r\n\t\t\t\t\tonReady(result);\r\n\t\t\t\t}\r\n\t\t\t});\r\n\t\t})\r\n\t\t\t.catch(errorMessage => {\r\n\t\t\t\tthis.resetState();\r\n\t\t\t\tconsole.warn(`MapViewDirections Error: ${errorMessage}`); // eslint-disable-line no-console\r\n\t\t\t\tonError && onError(errorMessage);\r\n\t\t\t});\r\n\t}\r\n\r\n\tfetchRoute(directionsServiceBaseUrl, origin, waypoints, destination, apikey, mode, language, region, precision, timePrecision, channel) {\r\n\r\n\t\t// Define the URL to call. Only add default parameters to the URL if it's a string.\r\n\t\tlet url = directionsServiceBaseUrl;\r\n\t\tif (typeof (directionsServiceBaseUrl) === 'string') {\r\n\t\t\turl += `?origin=${origin}&waypoints=${waypoints}&destination=${destination}&key=${apikey}&mode=${mode.toLowerCase()}&language=${language}&region=${region}`;\r\n\t\t\tif(timePrecision){\r\n\t\t\t\turl+=`&departure_time=${timePrecision}`;\r\n\t\t\t}\r\n\t\t\tif(channel){\r\n\t\t\t\turl+=`&channel=${channel}`;\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\treturn fetch(url)\r\n\t\t\t.then(response => response.json())\r\n\t\t\t.then(json => {\r\n\r\n\t\t\t\tif (json.status !== 'OK') {\r\n\t\t\t\t\tconst errorMessage = json.error_message || json.status || 'Unknown error';\r\n\t\t\t\t\treturn Promise.reject(errorMessage);\r\n\t\t\t\t}\r\n\r\n\t\t\t\tif (json.routes.length) {\r\n\r\n\t\t\t\t\tconst route = json.routes[0];\r\n\r\n\t\t\t\t\treturn Promise.resolve({\r\n\t\t\t\t\t\tdistance: route.legs.reduce((carry, curr) => {\r\n\t\t\t\t\t\t\treturn carry + curr.distance.value;\r\n\t\t\t\t\t\t}, 0) / 1000,\r\n\t\t\t\t\t\tduration: route.legs.reduce((carry, curr) => {\r\n\t\t\t\t\t\t\treturn carry + (curr.duration_in_traffic ? curr.duration_in_traffic.value : curr.duration.value);\r\n\t\t\t\t\t\t}, 0) / 60,\r\n\t\t\t\t\t\tcoordinates: (\r\n\t\t\t\t\t\t\t(precision === 'low') ?\r\n\t\t\t\t\t\t\t\tthis.decode([{polyline: route.overview_polyline}]) :\r\n\t\t\t\t\t\t\t\troute.legs.reduce((carry, curr) => {\r\n\t\t\t\t\t\t\t\t\treturn [\r\n\t\t\t\t\t\t\t\t\t\t...carry,\r\n\t\t\t\t\t\t\t\t\t\t...this.decode(curr.steps),\r\n\t\t\t\t\t\t\t\t\t];\r\n\t\t\t\t\t\t\t\t}, [])\r\n\t\t\t\t\t\t),\r\n\t\t\t\t\t\tfare: route.fare,\r\n\t\t\t\t\t\twaypointOrder: route.waypoint_order,\r\n\t\t\t\t\t});\r\n\r\n\t\t\t\t} else {\r\n\t\t\t\t\treturn Promise.reject();\r\n\t\t\t\t}\r\n\t\t\t})\r\n\t\t\t.catch(err => {\r\n\t\t\t\treturn Promise.reject(`Error on GMAPS route request: ${err}`);\r\n\t\t\t});\r\n\t}\r\n\r\n\trender() {\r\n\t\tconst { coordinates } = this.state;\r\n\r\n\t\tif (!coordinates) {\r\n\t\t\treturn null;\r\n\t\t}\r\n\r\n\t\tconst {\r\n\t\t\torigin, // eslint-disable-line no-unused-vars\r\n\t\t\twaypoints, // eslint-disable-line no-unused-vars\r\n\t\t\tsplitWaypoints, // eslint-disable-line no-unused-vars\r\n\t\t\tdestination, // eslint-disable-line no-unused-vars\r\n\t\t\tapikey, // eslint-disable-line no-unused-vars\r\n\t\t\tonReady, // eslint-disable-line no-unused-vars\r\n\t\t\tonError, // eslint-disable-line no-unused-vars\r\n\t\t\tmode, // eslint-disable-line no-unused-vars\r\n\t\t\tlanguage, // eslint-disable-line no-unused-vars\r\n\t\t\tregion, // eslint-disable-line no-unused-vars\r\n\t\t\tprecision,  // eslint-disable-line no-unused-vars\r\n\t\t\t...props\r\n\t\t} = this.props;\r\n\r\n\t\treturn (\r\n\t\t\t<MapView.Polyline coordinates={coordinates} {...props} />\r\n\t\t);\r\n\t}\r\n\r\n}\r\n\r\nMapViewDirections.propTypes = {\r\n\torigin: PropTypes.oneOfType([\r\n\t\tPropTypes.string,\r\n\t\tPropTypes.shape({\r\n\t\t\tlatitude: PropTypes.number.isRequired,\r\n\t\t\tlongitude: PropTypes.number.isRequired,\r\n\t\t}),\r\n\t]),\r\n\twaypoints: PropTypes.arrayOf(\r\n\t\tPropTypes.oneOfType([\r\n\t\t\tPropTypes.string,\r\n\t\t\tPropTypes.shape({\r\n\t\t\t\tlatitude: PropTypes.number.isRequired,\r\n\t\t\t\tlongitude: PropTypes.number.isRequired,\r\n\t\t\t}),\r\n\t\t]),\r\n\t),\r\n\tdestination: PropTypes.oneOfType([\r\n\t\tPropTypes.string,\r\n\t\tPropTypes.shape({\r\n\t\t\tlatitude: PropTypes.number.isRequired,\r\n\t\t\tlongitude: PropTypes.number.isRequired,\r\n\t\t}),\r\n\t]),\r\n\tapikey: PropTypes.string.isRequired,\r\n\tonStart: PropTypes.func,\r\n\tonReady: PropTypes.func,\r\n\tonError: PropTypes.func,\r\n\tmode: PropTypes.oneOf(['DRIVING', 'BICYCLING', 'TRANSIT', 'WALKING']),\r\n\tlanguage: PropTypes.string,\r\n\tresetOnChange: PropTypes.bool,\r\n\toptimizeWaypoints: PropTypes.bool,\r\n\tsplitWaypoints: PropTypes.bool,\r\n\tdirectionsServiceBaseUrl: PropTypes.string,\r\n\tregion: PropTypes.string,\r\n\tprecision: PropTypes.oneOf(['high', 'low']),\r\n\ttimePrecision: PropTypes.oneOf(['now', 'none']),\r\n\tchannel: PropTypes.string,\r\n};\r\n\r\nexport default MapViewDirections;\r\n"]},"metadata":{},"sourceType":"module"}